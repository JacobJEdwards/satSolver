-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/jacobjedwards/satSolver#readme</a>
@package satSolver
@version 0.1.0.0


module Options

-- | Command line options.
data Flag :: Type

-- | Run in interactive mode.
[Interactive] :: Flag

-- | Run in default demo mode.
[Demo] :: Flag

-- | Run the given expression.
[RunImmediate] :: Text -> Flag

-- | Run the given file.
[File] :: Text -> Flag

-- | Run sudoku.
[Sudoku] :: Maybe Text -> Flag

-- | Run nonogram.
[Nonogram] :: Maybe Text -> Flag

-- | Parse command line arguments. Returns the parsed command line options.
--   
--   <pre>
--   &gt;&gt;&gt; parseArgs ["-i"]
--   Interactive
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseArgs ["-d"]
--   Demo
--   </pre>
parseArgs :: [String] -> IO Flag
instance GHC.Show.Show Options.Options
instance GHC.Show.Show Options.Flag
instance GHC.Classes.Eq Options.Flag
instance GHC.Classes.Ord Options.Flag
instance Data.Data.Data Options.Flag


module Parser.Error

-- | The error type for the parser.
data Error :: Type -> Type -> Type

-- | The input ended unexpectedly.
[EndOfInput] :: Error i e

-- | An unexpected token was encountered.
[Unexpected] :: i -> Error i e

-- | A custom error occurred.
[CustomError] :: e -> Error i e

-- | The input is empty.
[Empty] :: Error i e
instance (GHC.Classes.Eq i, GHC.Classes.Eq e) => GHC.Classes.Eq (Parser.Error.Error i e)
instance (GHC.Show.Show i, GHC.Show.Show e) => GHC.Show.Show (Parser.Error.Error i e)
instance (GHC.Base.Semigroup i, GHC.Base.Semigroup e) => GHC.Base.Semigroup (Parser.Error.Error i e)
instance (GHC.Base.Monoid i, GHC.Base.Monoid e) => GHC.Base.Monoid (Parser.Error.Error i e)


module Parser.Input

-- | The <a>Input</a> type class for parsing
class (Eq i, IsString i, Monoid i) => Input (i :: Type) where {
    
    -- | The token type of the input.
    type Token i;
}

-- | Uncons the input.
uncons :: Input i => i -> Maybe (Token i, i)

-- | Get the head of the input.
head :: Input i => i -> Maybe (Token i)

-- | Check if the input is empty.
null :: Input i => i -> Bool

-- | Unpack the input to a string.
unpack :: Input i => i -> String
instance Parser.Input.Input Data.ByteString.Internal.Type.ByteString
instance Parser.Input.Input Data.Text.Internal.Text
instance Parser.Input.Input GHC.Base.String


module Parser.Result

-- | The result type for the parser.
data Result i e a
Errors :: [Error i e] -> Result i e a
Result :: a -> Result i e a
instance (GHC.Show.Show a, GHC.Show.Show e, GHC.Show.Show i) => GHC.Show.Show (Parser.Result.Result i e a)
instance GHC.Base.Functor (Parser.Result.Result i e)
instance GHC.Base.Applicative (Parser.Result.Result i e)
instance GHC.Base.Alternative (Parser.Result.Result i e)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Parser.Result.Result i e a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Parser.Result.Result i e a)
instance GHC.Base.Monad (Parser.Result.Result i e)


module Parser.Parsec

-- | The parser type.
newtype Parser i e o
Parser :: (i -> Result i e (i, o)) -> Parser i e o
[runParser] :: Parser i e o -> i -> Result i e (i, o)

-- | The base predicate parser. Succeeds if the predicate is true for the
--   next token. &gt;&gt;&gt; runParser (satisfy (== <tt>a</tt>)) "abc"
--   Result ("bc",<tt>a</tt>)
satisfy :: (Input i, Token i ~ a) => (a -> Bool) -> Parser i e a

-- | Parses a character. &gt;&gt;&gt; runParser (char <tt>a</tt>) "abc"
--   Result ("bc",<tt>a</tt>)
char :: (Input i, Token i ~ Char) => Char -> Parser i e Char

-- | Parses a digit. &gt;&gt;&gt; runParser digit "123" Result ("23",'1')
digit :: (Input i, Token i ~ Char) => Parser i e Char

-- | Parses a sequence of digits. &gt;&gt;&gt; runParser digits "123"
--   Result ("","123")
digits :: (Input i, Token i ~ Char) => Parser i e i

-- | Parses a newline character. &gt;&gt;&gt; runParser newline "na" Result
--   ("a",'n')
newline :: (Input i, Token i ~ Char) => Parser i e Char

-- | Parses a string. &gt;&gt;&gt; runParser (string "abc") "abcdef" Result
--   ("def","abc")
string :: (Input i, Token i ~ Char) => i -> Parser i e i

-- | Parses a space character. &gt;&gt;&gt; runParser space " a" Result
--   ("a",' ')
space :: (Input i, Token i ~ Char) => Parser i e Char

-- | Parses a sequence of space characters. &gt;&gt;&gt; runParser spaces "
--   a" Result ("a"," ")
spaces :: (Input i, Token i ~ Char) => Parser i e i

-- | Parses a symbol. &gt;&gt;&gt; runParser (symbol "abc") "abcdef" Result
--   ("def","abc")
symbol :: (Input i, Token i ~ Char) => i -> Parser i e i

-- | Parses any symbol from a list of symbols. &gt;&gt;&gt; runParser
--   (anySymbol ["abc", "def"]) "defghi" Result ("ghi","def")
anySymbol :: (Input i, Token i ~ Char) => [i] -> Parser i e i

-- | Parses a value between two parsers. &gt;&gt;&gt; runParser (between
--   (char '[') (char ']') (char <tt>a</tt>)) "[a]" Result ("", <tt>a</tt>)
between :: Parser i e o -> Parser i e o' -> Parser i e o'' -> Parser i e o''

-- | Parses a value between two symbols. &gt;&gt;&gt; runParser
--   (betweenSymbols "[" "]" (char <tt>a</tt>)) "[a]" Result ("",
--   <tt>a</tt>)
betweenSymbols :: (Input i, Token i ~ Char) => i -> i -> Parser i e a -> Parser i e a

-- | Parses a value between brackets. &gt;&gt;&gt; runParser (brackets
--   (char <tt>a</tt>)) "[a]" Result ("", <tt>a</tt>)
brackets :: (Input i, Token i ~ Char) => Parser i e a -> Parser i e a

-- | Parses a value between braces. &gt;&gt;&gt; runParser (braces (char
--   <tt>a</tt>)) "{a}" Result ("", <tt>a</tt>)
braces :: (Input i, Token i ~ Char) => Parser i e a -> Parser i e a

-- | Parses a value between parentheses. &gt;&gt;&gt; runParser (parens
--   (char <tt>a</tt>)) "(a)" Result ("", <tt>a</tt>)
parens :: (Input i, Token i ~ Char) => Parser i e a -> Parser i e a

-- | Parses a value between spaces. &gt;&gt;&gt; runParser (ignoreSpaces
--   (char <tt>a</tt>)) " a" Result ("", <tt>a</tt>)
ignoreSpaces :: (Input i, Token i ~ Char) => Parser i e a -> Parser i e a

-- | Parses a letter. &gt;&gt;&gt; runParser letter "abc" Result
--   ("bc",<tt>a</tt>)
letter :: (Input i, Token i ~ Char) => Parser i e Char

-- | Parses a sequence of letters. &gt;&gt;&gt; runParser letters "abc"
--   Result ("","abc")
letters :: (Input i, Token i ~ Char) => Parser i e i

-- | Parses the end of the input. &gt;&gt;&gt; runParser eof "" Result
--   ("",())
eof :: Input i => Parser i e ()

-- | Parses the next token without consuming it. &gt;&gt;&gt; runParser
--   lookahead "a" Result ("a",Just <tt>a</tt>)
lookahead :: (Input i, Token i ~ Char) => Parser i i (Maybe Char)

-- | The result type for the parser.
data Result i e a
Errors :: [Error i e] -> Result i e a
Result :: a -> Result i e a

-- | The error type for the parser.
data Error :: Type -> Type -> Type

-- | The input ended unexpectedly.
[EndOfInput] :: Error i e

-- | An unexpected token was encountered.
[Unexpected] :: i -> Error i e

-- | The <a>Input</a> type class for parsing
class (Eq i, IsString i, Monoid i) => Input (i :: Type) where {
    
    -- | The token type of the input.
    type Token i;
}

-- | Uncons the input.
uncons :: Input i => i -> Maybe (Token i, i)

-- | Get the head of the input.
head :: Input i => i -> Maybe (Token i)

-- | Check if the input is empty.
null :: Input i => i -> Bool

-- | Unpack the input to a string.
unpack :: Input i => i -> String

-- | Parses a left-associative chain of values. &gt;&gt;&gt; runParser
--   (chainl1 (char <tt>a</tt>) (char <a>+</a>)) "a+a+a" Result ("","+")
chainl1 :: Parser i e a -> Parser i e (a -> a -> a) -> Parser i e a

-- | Parses a list of values until the end parser succeeds. &gt;&gt;&gt;
--   runParser (manyTill (char <tt>a</tt>) (char <tt>b</tt>)) "aaab" Result
--   ("b","aaa")
manyTill :: Parser i e a -> Parser i e b -> Parser i e [a]

-- | Parses a list of values until the end parser succeeds. &gt;&gt;&gt;
--   runParser (someTill (char <tt>a</tt>) (char <tt>b</tt>)) "aaab" Result
--   ("b","aaa")
someTill :: Parser i e a -> Parser i e b -> Parser i e [a]

-- | Tries to parse a value. If the parser fails, it returns an empty
--   result. &gt;&gt;&gt; runParser (try (char <tt>a</tt>)) "b" Errors []
try :: Parser i e a -> Parser i e a

-- | Parses a space character that is not a newline. &gt;&gt;&gt; runParser
--   spaceNoNewline " a" Result ("a",' ')
spaceNoNewline :: (Input i, Token i ~ Char) => Parser i e Char

-- | Parses a sequence of space characters that are not newlines.
--   &gt;&gt;&gt; runParser spacesNoNewline " a" Result ("a"," ")
spacesNoNewline :: (Input i, Token i ~ Char) => Parser i e i

-- | Zero or more.
many :: Alternative f => f a -> f [a]

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | One or none.
--   
--   It is useful for modelling any computation that is allowed to fail.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the <a>Alternative</a> instance of <a>Control.Monad.Except</a>,
--   the following functions:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.Except
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; canFail = throwError "it failed" :: Except String Int
--   
--   &gt;&gt;&gt; final = return 42                :: Except String Int
--   </pre>
--   
--   Can be combined by allowing the first function to fail:
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ canFail *&gt; final
--   Left "it failed"
--   
--   &gt;&gt;&gt; runExcept $ optional canFail *&gt; final
--   Right 42
--   </pre>
optional :: Alternative f => f a -> f (Maybe a)
instance GHC.Base.Functor (Parser.Parsec.Parser i e)
instance GHC.Base.Applicative (Parser.Parsec.Parser i e)
instance GHC.Base.Alternative (Parser.Parsec.Parser i e)
instance GHC.Base.Monad (Parser.Parsec.Parser i e)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Parser.Parsec.Parser i e a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Parser.Parsec.Parser i e a)


module Parser


module SAT.Expr

-- | The <a>Expr</a> type.
data Expr (a :: Type)
[Var] :: a -> Expr a
[Not] :: Expr a -> Expr a
[And] :: Expr a -> Expr a -> Expr a
[Or] :: Expr a -> Expr a -> Expr a
[Val] :: Bool -> Expr a
[Implies] :: Expr a -> Expr a -> Expr a
(.||.) :: Expr a -> Expr a -> Expr a
infixr 3 .||.
(.&&.) :: Expr a -> Expr a -> Expr a
infixr 3 .&&.
(.!.) :: Expr a -> Expr a
infixr 3 .!.

-- | Gets the value of a constant expression.
unVal :: Expr a -> Bool

-- | Converts an expression to a list.
--   
--   <pre>
--   &gt;&gt;&gt; toList (Var 1 .&amp;&amp;. Var 2)
--   [1, 2]
--   </pre>
toList :: Expr a -> [a]

-- | Combines a list of expressions with <a>Or</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ors [Var 1, Var 2]
--   Or (Var 1) (Var 2)
--   </pre>
ors :: [Expr a] -> Expr a

-- | Combines a list of expressions with <a>And</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ands [Var 1, Var 2]
--   And (Var 1) (Var 2)
--   </pre>
ands :: [Expr a] -> Expr a

-- | Converts a literal to a variable.
--   
--   <pre>
--   &gt;&gt;&gt; toVar 1
--   Var 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toVar (-1)
--   Not (Var 1)
--   </pre>
toVar :: Int -> Expr Int

-- | The solutions type.
type Solutions = IntSet
instance GHC.Classes.Ord a => GHC.Classes.Ord (SAT.Expr.Expr a)
instance Data.Data.Data a => Data.Data.Data (SAT.Expr.Expr a)
instance GHC.Read.Read a => GHC.Read.Read (SAT.Expr.Expr a)
instance GHC.Base.Functor SAT.Expr.Expr
instance Data.Foldable.Foldable SAT.Expr.Expr
instance Data.Traversable.Traversable SAT.Expr.Expr
instance GHC.Generics.Generic (SAT.Expr.Expr a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (SAT.Expr.Expr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (SAT.Expr.Expr a)
instance GHC.Show.Show a => GHC.Show.Show (SAT.Expr.Expr a)
instance GHC.Base.Semigroup (SAT.Expr.Expr a)
instance GHC.Base.Monoid (SAT.Expr.Expr a)
instance GHC.Base.Applicative SAT.Expr.Expr
instance GHC.Base.Monad SAT.Expr.Expr


module SAT.CNF

-- | Applies the laws of distribution and De Morgan to an expression.
--   
--   <pre>
--   &gt;&gt;&gt; applyLaws (Or (And (Var 1) (Var 2)) (Not (Var 3)))
--   And (Or (Not (Var 3)) (Var 1)) (Or (Not (Var 3)) (Var 2))
--   </pre>
applyLaws :: Eq a => Expr a -> Expr a

-- | Converts an expression to CNF.
--   
--   <pre>
--   &gt;&gt;&gt; toCNF (Or (And (Var 1) (Var 2)) (Not (Var 3)))
--   CNF [[-3,1],[-3,2]]
--   </pre>
toCNF :: Expr Int -> CNF

-- | The CNF type.
newtype CNF
CNF :: [Clause] -> CNF

-- | The clause type.
type Clause = [Literal]

-- | The literal type.
type Literal = Int

-- | Adds a clause to a CNF.
--   
--   <pre>
--   &gt;&gt;&gt; addClause (CNF [[1,2]]) [3]
--   CNF [[3],[1,2]]
--   </pre>
addClause :: CNF -> Clause -> CNF
type Assignment = IntMap Bool
type DecisionLevel = Int

-- | Checks if a literal is negative.
--   
--   <pre>
--   &gt;&gt;&gt; isNegative (-1)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNegative 1
--   False
--   </pre>
--   
--   <pre>
--   isNegative x == (x &lt; 0)
--   </pre>
isNegative :: Literal -> Bool
tseitin :: Expr Int -> State Int (CNF, Literal)
toTseitin :: Expr Int -> CNF

-- | Gets the variable of a literal.
--   
--   <pre>
--   &gt;&gt;&gt; varOfLiteral 1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; varOfLiteral (-1)
--   1
--   </pre>
varOfLiteral :: Literal -> Int

-- | Returns the value of a variable in an assignment.
varValue :: Assignment -> Int -> Maybe Bool

-- | Returns the value of a literal in an assignment.
literalValue :: Assignment -> Literal -> Maybe Bool
negateLiteral :: Literal -> Literal
initAssignment :: IntSet -> Assignment
instance GHC.Generics.Generic SAT.CNF.CNF
instance GHC.Classes.Ord SAT.CNF.CNF
instance GHC.Show.Show SAT.CNF.CNF
instance GHC.Classes.Eq SAT.CNF.CNF
instance Control.DeepSeq.NFData SAT.CNF.CNF


module SAT.DIMACS.CNF

-- | Converts a list of clauses to an expression.
toExpr :: [Clause] -> Expr Literal

-- | Converts an expression to dimacs.
--   
--   <pre>
--   &gt;&gt;&gt; fromExpr (Or (Var 1) (Var 2))
--   DIMACS {numVars = 2, numClauses = 1, clauses = [[1,2]], comments = ["This is a CNF formula generated from an expression."]}
--   </pre>
fromExpr :: Expr Literal -> DIMACS

-- | The clause type.
type Clause = [Literal]

-- | The DIMACS type.
data DIMACS
DIMACS :: Integer -> Integer -> [Clause] -> [Text] -> DIMACS
[numVars] :: DIMACS -> Integer
[numClauses] :: DIMACS -> Integer
[clauses] :: DIMACS -> [Clause]
[comments] :: DIMACS -> [Text]

-- | An example DIMACS formula.
exampleDIMACS :: DIMACS

-- | The literal type.
type Literal = Int

-- | Converts a DIMACS formula to CNF.
--   
--   <pre>
--   &gt;&gt;&gt; toCNF exampleDIMACS
--   CNF {clauses = [[1,2],[-1,3]]}
--   </pre>
toCNF :: DIMACS -> CNF

-- | Converts a CNF formula to DIMACS.
--   
--   <pre>
--   &gt;&gt;&gt; fromCNF (CNF [[1,2],[-1,3]])
--   DIMACS {numVars = 3, numClauses = 2, clauses = [[1,2],[-1,3]], comments = ["This is a CNF formula generated from a CNF formula."]}
--   </pre>
fromCNF :: CNF -> DIMACS
instance GHC.Generics.Generic SAT.DIMACS.CNF.DIMACS
instance GHC.Show.Show SAT.DIMACS.CNF.DIMACS
instance GHC.Classes.Eq SAT.DIMACS.CNF.DIMACS
instance Control.DeepSeq.NFData SAT.DIMACS.CNF.DIMACS


module SAT.DIMACS.Parser

-- | Parses a DIMACS formula.
parseCNF :: Text -> Result Text Text (Text, DIMACS)

-- | Parses a DIMACS formula from a file.
parseFile :: Text -> IO (Maybe DIMACS)

-- | Parses a DIMACS formula. Returns <a>Nothing</a> if the input is
--   invalid. Returns <a>Just</a> the formula otherwise.
parse :: Text -> Maybe DIMACS


module SAT.DIMACS

module SAT.Old.Optimisers

module SAT.Old.Solver


module SAT.Parser

-- | Parses an expression from a string. Returns <a>Nothing</a> if the
--   input is invalid. Returns <a>Just</a> the expression otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; parse "1 and 2 or 3"
--   Just (1 `And` (2 `Or` 3))
--   </pre>
parse :: Text -> Maybe (Expr Int)


module SAT.Polarity

-- | The <a>Polarity</a> type.
data Polarity
Positive :: Polarity
Negative :: Polarity
Mixed :: Polarity

-- | Flips the polarity.
--   
--   <pre>
--   &gt;&gt;&gt; flipPolarity Positive
--   Negative
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flipPolarity Negative
--   Positive
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flipPolarity Mixed
--   Mixed
--   </pre>
--   
--   <pre>
--   flipPolarity (flipPolarity x) == x
--   </pre>
flipPolarity :: Polarity -> Polarity
instance GHC.Read.Read SAT.Polarity.Polarity
instance GHC.Generics.Generic SAT.Polarity.Polarity
instance GHC.Show.Show SAT.Polarity.Polarity
instance GHC.Classes.Ord SAT.Polarity.Polarity
instance GHC.Classes.Eq SAT.Polarity.Polarity
instance Control.DeepSeq.NFData SAT.Polarity.Polarity
instance GHC.Base.Semigroup SAT.Polarity.Polarity
instance GHC.Base.Monoid SAT.Polarity.Polarity


module SAT.VSIDS

-- | The VSIDS type.
type VSIDS = IntMap Double

-- | Initializes the VSIDS.
--   
--   <pre>
--   &gt;&gt;&gt; initVSIDS (CNF [[1, 2], [2, 3], [3, 4]])
--   fromList [(1,1.0),(2,2.0),(3,2.0),(4,1.0)]
--   </pre>
initVSIDS :: CNF -> VSIDS

-- | Decays the scores.
--   
--   <pre>
--   &gt;&gt;&gt; decay (IntMap.fromList [(1, 1), (2, 2), (3, 3)])
--   WAS fromList [(1,0.99),(2,1.98),(3,2.97)]
--   NOW fromList [(1,0.99),(2,1.98),(3,2.9699999999999998)]
--   </pre>
decay :: VSIDS -> VSIDS

-- | Adjusts the score of a variable.
--   
--   <pre>
--   &gt;&gt;&gt; adjustScore 1 (IntMap.fromList [(1, 1), (2, 2), (3, 3)])
--   fromList [(1,2.0),(2,2.0),(3,3.0)]
--   </pre>
adjustScore :: Literal -> VSIDS -> VSIDS

-- | Updates the score of a variable.
--   
--   <pre>
--   &gt;&gt;&gt; updateScore 1 2 (IntMap.fromList [(1, 1), (2, 2), (3, 3)])
--   fromList [(1,2.0),(2,2.0),(3,3.0)]
--   </pre>
updateScore :: Literal -> Double -> VSIDS -> VSIDS

-- | The decay factor.
decayFactor :: Double
adjustScores :: Clause -> VSIDS -> VSIDS
pickLiteral :: VSIDS -> Literal

module SAT.Monad

-- | The solver monad.
type SolverM = RWST CNF SolverLog SolverState Maybe

-- | State methods
--   
--   Gets the propagation stack.
getPropagationStack :: SolverM [Literal]

-- | The solver state. Contains information for solving and any
--   optimisations.
data SolverState
SolverState :: Assignment -> Trail -> ImplicationGraph -> WatchedLiterals -> DecisionLevel -> ClauseDB -> VSIDS -> IntSet -> [Literal] -> Int -> Int -> SolverState
[assignment] :: SolverState -> Assignment
[trail] :: SolverState -> Trail
[implicationGraph] :: SolverState -> ImplicationGraph
[watchedLiterals] :: SolverState -> WatchedLiterals
[decisionLevel] :: SolverState -> DecisionLevel
[clauseDB] :: SolverState -> ClauseDB
[vsids] :: SolverState -> VSIDS
[variables] :: SolverState -> IntSet
[propagationStack] :: SolverState -> [Literal]
[lubyCount] :: SolverState -> Int
[lubyThreshold] :: SolverState -> Int

-- | The solver log.
type SolverLog = [String]

-- | The trail type (the previous assignments).
type Trail = [(Literal, DecisionLevel, Bool)]

-- | The reason for a conflict or assignment.
type Reason = Clause

-- | The implication graph (maybe turn into a more explicit graph).
type ImplicationGraph = IntMap (Literal, Maybe Reason, DecisionLevel)

-- | Watched literals (literals in clauses that are being watched).
data WatchedLiterals
WatchedLiterals :: IntMap [Clause] -> Map Clause [Literal] -> WatchedLiterals
[literals] :: WatchedLiterals -> IntMap [Clause]
[clauses] :: WatchedLiterals -> Map Clause [Literal]

-- | Gets the assignment.
getAssignment :: SolverM Assignment

-- | Gets the trail.
getTrail :: SolverM Trail

-- | Gets the implication graph.
getImplicationGraph :: SolverM ImplicationGraph

-- | Gets the watched literals.
getWatchedLiterals :: SolverM WatchedLiterals
initWatchedLiterals :: CNF -> WatchedLiterals

-- | Gets the decision level.
getDecisionLevel :: SolverM DecisionLevel

-- | Gets the VSIDS.
getVSIDS :: SolverM VSIDS

-- | Logs a message.
logM :: String -> SolverM ()
ifM :: Monad m => m Bool -> m a -> m a -> m a
guardM :: MonadPlus m => m Bool -> m ()
notM :: Monad m => m Bool -> m Bool
learn :: Clause -> SolverM ()
increaseDecisionLevel :: SolverM ()
getClauseDB :: SolverM ClauseDB
instance GHC.Generics.Generic SAT.Monad.WatchedLiterals
instance GHC.Read.Read SAT.Monad.WatchedLiterals
instance GHC.Classes.Ord SAT.Monad.WatchedLiterals
instance GHC.Classes.Eq SAT.Monad.WatchedLiterals
instance GHC.Show.Show SAT.Monad.WatchedLiterals
instance GHC.Show.Show SAT.Monad.SolverState
instance Control.DeepSeq.NFData SAT.Monad.WatchedLiterals

module SAT.Restarts
computeNextLubyThreshold :: Int -> Int
luby :: Int -> Int
increaseLubyCount :: SolverM ()


module SAT.Optimisers

-- | Propagates a unit clause in a CNF.
--   
--   <pre>
--   &gt;&gt;&gt; unitPropagate (CNF [[1, 2], [-2, -3], [3, 4]]) IntMap.empty 0
--   (CNF {clauses = [[1,2],[-2,-3],[3,4]]},fromList [])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unitPropagate (CNF [[1], [2, 3], [3, 4]]) IntMap.empty 0
--   (CNF {clauses = [[2,3],[3,4]]},fromList [(1,True)])
--   </pre>
unitPropagate :: CNF -> Assignment -> DecisionLevel -> (Assignment, CNF)

-- | Substitutes a literal in a CNF.
--   
--   <pre>
--   &gt;&gt;&gt; substitute 1 True (CNF [[1, 2], [2, 3], [3, 4]])
--   CNF {clauses = [[2,3],[3,4]]}
--   </pre>
substitute :: Literal -> Bool -> CNF -> CNF

-- | Collects all literals in a CNF.
--   
--   <pre>
--   &gt;&gt;&gt; collectLiterals (CNF [[1, 2], [2, 3], [3, 4]])
--   [1,2,2,3,3,4]
--   </pre>
collectLiterals :: CNF -> [Int]

-- | Collects all literals in a CNF and returns them as a set.
--   
--   <pre>
--   &gt;&gt;&gt; collectLiteralsToSet (CNF [[1, 2], [2, 3], [3, 4]])
--   fromList [1,2,3,4]
--   </pre>
collectLiteralsToSet :: CNF -> IntSet

-- | Removes duplicates from a list.
--   
--   <pre>
--   &gt;&gt;&gt; uniqueOnly [1, 2, 3, 2, 1]
--   [1,2,3]
--   </pre>
uniqueOnly :: forall a. Ord a => [a] -> [a]

-- | eliminates any literals that are either positive or negative from the
--   CNF and updates the assignment returns the updated CNF and assignment
eliminateLiterals :: CNF -> Assignment -> (Assignment, CNF)

-- | Assigns a value to a literal.
--   
--   <pre>
--   &gt;&gt;&gt; assign IntMap.empty 1 True 0
--   fromList [(1,True)]
--   </pre>
assign :: Assignment -> Literal -> Bool -> Assignment

-- | Applies a partial assignment to a CNF.
--   
--   <pre>
--   &gt;&gt;&gt; partialAssignment (IntMap.fromList [(1, (True, 0))]) (CNF [[1, 2], [-2, -3], [3, 4]])
--   CNF {clauses = [[2],[-3],[3,4]]}
--   </pre>
partialAssignment :: Assignment -> CNF -> CNF

-- | Picks a variable.
--   
--   <pre>
--   &gt;&gt;&gt; pickVariable (IntMap.fromList [(1, 1), (2, 2), (3, 3)])
--   Just (3,fromList [(1,1.0),(2,2.0)])
--   </pre>
pickVariable :: VSIDS -> Maybe (Literal, VSIDS)
pickVariableM :: SolverM (Maybe Literal)

-- | Finds the polarities of the literals in a CNF.
--   
--   <pre>
--   &gt;&gt;&gt; literalPolarities (CNF [[1, 2], [-2, -3], [3, 4]])
--   fromList [(1,Positive),(2,Mixed),(3,Mixed),(4,Positive)]
--   </pre>
literalPolarities :: CNF -> IntMap Polarity
decayM :: SolverM ()
eliminateLiteralsM :: SolverM ()

-- | Finds a unit clause in a CNF (a clause with only one literal).
--   
--   <pre>
--   &gt;&gt;&gt; findUnitClause (CNF [[1, 2], [-2, -3], [3, 4]])
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findUnitClause (CNF [[1], [2, 3], [3, 4]])
--   Just (1,True)
--   </pre>
findUnitClause :: CNF -> Maybe (Int, Bool)
unitPropagateM :: SolverM (Maybe Clause)
assignM :: Literal -> Bool -> SolverM ()

-- | Removes tautologies from a CNF. A tautology is a clause that contains
--   both a literal and its negation, and is always true therefore. This
--   function removes all such clauses from the CNF.
--   
--   <pre>
--   &gt;&gt;&gt; removeTautologies (CNF [[-2, 2], [-2, -3], [3, 4]])
--   CNF {[[-2,-3],[3,4]]}
--   </pre>
removeTautologies :: CNF -> CNF

-- | Checks if a CNF is satisfied
--   
--   <pre>
--   &gt;&gt;&gt; isSat (CNF [[1, 2], [2, 3], [3, 4]])
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSat (CNF [])
--   True
--   </pre>
isSat :: CNF -> Bool

-- | Checks if a CNF is unsatisfiable
--   
--   <pre>
--   &gt;&gt;&gt; isUnsat (CNF [[1, 2], [2, 3], [3, 4]])
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isUnsat (CNF [[]])
--   True
--   </pre>
isUnsat :: CNF -> Bool

-- | Backtracks to a given decision level.
backtrack :: DecisionLevel -> SolverM ()
analyseConflict :: Clause -> SolverM (Clause, DecisionLevel)
addDecision :: Literal -> SolverM ()
addPropagation :: Literal -> Clause -> SolverM ()
isSatisfied :: SolverM Bool
adjustScoresM :: Clause -> SolverM ()
getClauseStatus :: Clause -> SolverM ClauseStatus
findCanditateWatchedLiteral :: Clause -> SolverM (Maybe Literal)
data ClauseStatus
Unit :: Literal -> ClauseStatus
UNSAT :: ClauseStatus
SAT :: ClauseStatus
Unresolved :: ClauseStatus
pickLiteralM :: SolverM Literal
instance GHC.Show.Show SAT.Optimisers.ClauseStatus
instance GHC.Classes.Eq SAT.Optimisers.ClauseStatus

module SAT.Preprocessing
preprocess :: SolverM (Maybe Clause)


-- | simplify for now, don't use partials, don't worry about inefficiencies
--   that is what watch literals aim to solve or i could have my partial
--   list of maybe clause, which i can index on the main clauses to get
--   them but must compare that to watched literals when i implement that
--   watched literals can also be checked for tautolofy should wathced
--   literals be stored as the abs value or either ?
--   
--   so for now, when finding units just compare the main cnf against the
--   assignment follow the tutorial (but with ig) experiment with the use
--   of pure literals, not sure how they fit in with the watched literals
--   (maybe tautlogies could be useful too)
--   
--   maybe worth dragging the cnf around in state to add learned clauses
--   iwht little hassle consider not using vsids for now, just bare minimum
--   biggest issue is that i need the conflicting clause to learn from it,
--   hence lack of partials another issue is if my solver is dramatically
--   more inefficient due to partials lacking, how can i know if cdcl is
--   working ?? i suppose i check the learned clauses against other solvers
--   
--   simplify simplify simpify
--   
--   issue with using partial assignment to check for isSat is learned
--   clauses
module SAT.Solver

-- | Checks if a CNF is satisfiable.
satisfiable :: CNF -> Bool

-- | The solutions type.
type Solutions = IntSet

-- | Checks if a value is in the solutions.
--   
--   <pre>
--   &gt;&gt;&gt; checkValue (IntSet.fromList [1, 2, 3]) 2
--   True
--   </pre>
checkValue :: Solutions -> Literal -> Bool

-- | Finds a free variable at random.
findFreeVariable :: CNF -> Maybe Literal
getSolutions :: CNF -> Maybe Solutions
bruteForce :: Expr Int -> Maybe Solutions
withUnitPropagation :: Expr Int -> Maybe Solutions
withPureLiteralElimination :: Expr Int -> Maybe Solutions
withPureLiteralAndUnitPropagation :: Expr Int -> Maybe Solutions
pureLitOnlyAsPreprocess :: Expr Int -> Maybe Solutions
literalEvery100 :: Expr Int -> Maybe Solutions
withTautologyElimination :: Expr Int -> Maybe Solutions


module SAT


module Nonogram.Solver

-- | Represents a nonogram.
data Nonogram
Nonogram :: [Constraint] -> [Constraint] -> [[Cell]] -> Nonogram
[rows] :: Nonogram -> [Constraint]
[cols] :: Nonogram -> [Constraint]
[solution] :: Nonogram -> [[Cell]]

-- | Represents a variable in a nonogram.
data Variable
Variable :: Int -> Int -> Cell -> Variable
[row] :: Variable -> Int
[col] :: Variable -> Int
[filled] :: Variable -> Cell

-- | Represents a cell in a nonogram.
data Cell
Filled :: Cell
Unfilled :: Cell
Unknown :: Cell

-- | Represents a constraint in a nonogram (e.g. [1, 2, 3]) (nearly CNF)
type Constraint = [Int]

-- | Represents the size of a nonogram.
type Size = Int

-- | Represents a mask in a nonogram.
type Mask = [Int]

-- | Encodes a variable to an integer.
--   
--   <pre>
--   &gt;&gt;&gt; encodeVar exampleNonogram (Variable 1 1 Filled)
--   2
--   </pre>
encodeVar :: Nonogram -> Variable -> Literal

-- | Decodes the solution to the nonogram.
--   
--   <pre>
--   &gt;&gt;&gt; decodeSolution exampleNonogram (Solutions [])
--   ...
--   </pre>
decodeSolution :: Nonogram -> Solutions -> Nonogram

-- | Converts a nonogram to DIMACS format.
--   
--   <pre>
--   &gt;&gt;&gt; toDIMACS exampleNonogram
--   DIMACS {numVars = 20, numClauses = 0, clauses = ..., comments = ["Nonogram"]}
--   </pre>
toDIMACS :: Nonogram -> DIMACS

-- | Example nonogram.
fiveByFive :: Nonogram

-- | Example nonogram.
fiveByFive2 :: Nonogram

-- | Example nonogram.
twoByTwo :: Nonogram

-- | Example nonogram.
oneByOne :: Nonogram

-- | Example nonogram.
eightByEight :: Nonogram
instance GHC.Generics.Generic Nonogram.Solver.Cell
instance GHC.Classes.Eq Nonogram.Solver.Cell
instance GHC.Generics.Generic Nonogram.Solver.Nonogram
instance GHC.Classes.Eq Nonogram.Solver.Nonogram
instance GHC.Generics.Generic Nonogram.Solver.Variable
instance GHC.Show.Show Nonogram.Solver.Variable
instance GHC.Classes.Eq Nonogram.Solver.Variable
instance Control.DeepSeq.NFData Nonogram.Solver.Cell
instance Control.DeepSeq.NFData Nonogram.Solver.Nonogram
instance Control.DeepSeq.NFData Nonogram.Solver.Variable
instance GHC.Show.Show Nonogram.Solver.Nonogram
instance GHC.Show.Show Nonogram.Solver.Cell
instance GHC.Enum.Enum Nonogram.Solver.Cell
instance GHC.Enum.Bounded Nonogram.Solver.Cell


module Nonogram.Parser

-- | Parses a nonogram from a string. Returns <a>Nothing</a> if the input
--   is invalid. Returns <a>Just</a> the nonogram otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; todo
--   </pre>
parse :: Text -> Maybe Nonogram


module Nonogram


module Sudoku.Solver

-- | Example Sudoku puzzles
--   
--   A 4x4 Sudoku puzzle
sudokuFour :: Sudoku

-- | A 9x9 Sudoku puzzle
sudokuNine :: Sudoku

-- | A 16x16 Sudoku puzzle
sudokuSixteen :: Sudoku
sudokuTwentyfive :: Sudoku

-- | The Sudoku
data Sudoku
Sudoku :: Board -> Size -> Sudoku
[board] :: Sudoku -> Board
[size] :: Sudoku -> Size

-- | The Size of the Sudoku
data Size
TwoByTwo :: Size
FourByFour :: Size
NineByNine :: Size
SixteenBySixteen :: Size
TwentyFiveByTwentyFive :: Size

-- | The Sudoku variable
data Variable
Variable :: Int -> Int -> Int -> Variable
[row] :: Variable -> Int
[col] :: Variable -> Int
[num] :: Variable -> Int

-- | Converts a Sudoku to DIMACS
--   
--   <pre>
--   &gt;&gt;&gt; toDIMACS sudokuFour
--   ...
--   </pre>
toDIMACS :: Sudoku -> DIMACS

-- | Decodes a solution to a Sudoku
--   
--   <pre>
--   &gt;&gt;&gt; decodeSolution sudokuFour [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
--   1 2 3 4
--   </pre>
decodeSolution :: Sudoku -> Solutions -> Sudoku

-- | Encodes a variable to a DIMACS literal
--   
--   <pre>
--   &gt;&gt;&gt; encodeVar sudokuFour (Variable 1 1 1)
--   1
--   </pre>
encodeVar :: Sudoku -> Variable -> Literal

-- | The Sudoku board
type Board = [[Int]]
sudokuEmpty :: Sudoku
instance GHC.Generics.Generic Sudoku.Solver.Variable
instance GHC.Classes.Ord Sudoku.Solver.Variable
instance GHC.Show.Show Sudoku.Solver.Variable
instance GHC.Classes.Eq Sudoku.Solver.Variable
instance GHC.Generics.Generic Sudoku.Solver.Size
instance GHC.Classes.Ord Sudoku.Solver.Size
instance GHC.Show.Show Sudoku.Solver.Size
instance GHC.Classes.Eq Sudoku.Solver.Size
instance GHC.Generics.Generic Sudoku.Solver.Sudoku
instance GHC.Classes.Eq Sudoku.Solver.Sudoku
instance Control.DeepSeq.NFData Sudoku.Solver.Sudoku
instance Control.DeepSeq.NFData Sudoku.Solver.Variable
instance Control.DeepSeq.NFData Sudoku.Solver.Size
instance GHC.Show.Show Sudoku.Solver.Sudoku
instance GHC.Enum.Enum Sudoku.Solver.Size
instance GHC.Enum.Bounded Sudoku.Solver.Size


module Sudoku.Parser

-- | Parses a sudoku from a string. Returns <a>Nothing</a> if the input is
--   invalid. Returns <a>Just</a> the sudoku otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; parse "1 2 3 -\n4 5 6 -\n7 8 9 -"
--   Just (Sudoku [[1, 2, 3], [4, 5, 6], [7, 8, 9]] 3)
--   </pre>
parse :: Text -> Maybe Sudoku


module Sudoku


module Problem

-- | Represents a problem that can be solved by the SAT solver.
class Problem (a :: Type) where {
    
    -- | The type of variables in the problem.
    type Variable a;
}

-- | Converts the problem to DIMACS format.
toDIMACS :: Problem a => a -> DIMACS

-- | Decodes the solution to the problem.
decode :: Problem a => a -> Solutions -> a

-- | Encodes a variable to an integer.
encodeVar :: Problem a => a -> Variable a -> Int

-- | Parses a problem from a string.
example :: Problem a => a

-- | Parses a problem from a string.
parse :: Problem a => Text -> Maybe a

-- | Parses a problem from a file.
parseFile :: Problem a => Text -> IO (Maybe a)

-- | Solves a problem. Returns <a>Nothing</a> if the problem is
--   unsatisfiable. Returns <a>Just</a> the solution if the problem is
--   satisfiable.
--   
--   <pre>
--   &gt;&gt;&gt; solve Sudoku.sudokuSixteen
--   Just ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; solve Nonogram.exampleNonogram
--   Just ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; solve DIMACS.exampleDIMACS
--   Just ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; solve (SAT.toCNF (SAT.fromExpr (SAT.Var 1)))
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; solve (SAT.toCNF (SAT.fromExpr (SAT.Not (SAT.Var 1)) `SAT.And` SAT.fromExpr (SAT.Var 1)))
--   Nothing
--   </pre>
solve :: Problem a => a -> Maybe a

-- | Converts a problem to an expression.
--   
--   <pre>
--   &gt;&gt;&gt; toExpr Sudoku.sudokuSixteen
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toExpr Nonogram.exampleNonogram
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toExpr DIMACS.exampleDIMACS
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toExpr (SAT.toCNF (SAT.fromExpr (SAT.Var 1)))
--   SAT.Var 1
--   </pre>
toExpr :: Problem a => a -> Expr Int

-- | Converts a problem to CNF.
--   
--   <pre>
--   &gt;&gt;&gt; toCNF Sudoku.sudokuSixteen
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toCNF Nonogram.exampleNonogram
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toCNF DIMACS.exampleDIMACS
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toCNF (SAT.toCNF (SAT.fromExpr (SAT.Var 1)))
--   CNF [[1]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toCNF (SAT.toCNF (SAT.fromExpr (SAT.Not (SAT.Var 1)) `SAT.And` SAT.fromExpr (SAT.Var 1)))
--   CNF [[-1][1]]
--   </pre>
toCNF :: Problem a => a -> CNF

-- | Checks if a problem is satisfiable.
--   
--   <pre>
--   &gt;&gt;&gt; isSatisfiable Sudoku.sudokuSixteen
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSatisfiable Nonogram.exampleNonogram
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSatisfiable DIMACS.exampleDIMACS
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSatisfiable (SAT.toCNF (SAT.fromExpr (SAT.Var 1)))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSatisfiable (SAT.toCNF (SAT.fromExpr (SAT.Not (SAT.Var 1)) `SAT.And` SAT.fromExpr (SAT.Var 1)))
--   False
--   </pre>
isSatisfiable :: Problem a => a -> Bool

-- | Gets the number of clauses in a problem.
--   
--   <pre>
--   &gt;&gt;&gt; getNumClauses Sudoku.sudokuSixteen
--   ...
--   </pre>
getNumClauses :: Problem a => a -> Integer
getNumVars :: Problem a => a -> Integer
solveWith :: Problem a => (Expr Int -> Maybe Solutions) -> a -> Maybe a
averageClauseLength :: Problem a => a -> Double
getTotalNumLiterals :: Problem a => a -> Integer
instance Problem.Problem Sudoku.Solver.Sudoku
instance Problem.Problem Nonogram.Solver.Nonogram
instance Problem.Problem SAT.DIMACS.CNF.DIMACS
instance Problem.Problem (SAT.Expr.Expr GHC.Types.Int)
instance Problem.Problem SAT.CNF.CNF

module TypeLevel.SAT
